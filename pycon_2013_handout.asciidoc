Part 1 - Getting Django set up using a Functional Test
======================================================================

Open a new file called 'functional_tests.py'

[source,python]
----
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://localhost:8000')

assert 'Django' in browser.title
print 'OK!'
----

Expected failure:  `AssertionError`

In a separate console window:

----
django-admin.py startproject mysite
----

Should give you a folder structure like this:

----
mysite
|-- manage.py
`-- mysite
    |-- __init__.py
    |-- settings.py
    |-- urls.py
    `-- wsgi.py
----

If it doesn't, you're probably on the wrong version of Django. You'll probably
have to switch to someone else's PC.


----
cd mysite
python manage.py runserver
----

Expected pass: test prints 'OK!'

NOTE: Ask me about: what is the point of TDD? How did I get into it?
NOTE: If it doesn't work, check the port -- is `runserver` using port 8000, or is 
it on a different one? 8001?


Part 2 - `unittest` and looking for our site's home page
======================================================================

We update 'functional_tests.py' to use the `unittest' module.

[source,python]
----

import unittest
from selenium import webdriver

class PollsFunctionalTest(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()

    def tearDown(self):
        self.browser.quit()

    def test_voting_on_a_poll(self):
        # Elspeth goes to check out a cool new polls site she's heard about
        self.browser.get('http://localhost:8000')

        # It is obviously all about polls:
        self.assertIn('Poll, self.browser.title)

        self.fail('finish this test')

if __name__ == '__main__':
    unittest.main()
----

NOTE: Ask me about: why is unittest helpful?  what is assertIn?

NOTE: Ask me about: setUp, tearDown

NOTE: __name__ == '__main__' 

NOTE: self.browser.implicitly_wait()

Expected failure:  

    AssertionError: 'Polls' not found in u'Welcome to Django'



Finish writing the FT as comments:

[source,python]
----
def test_voting_on_a_poll(self):
    # Elspeth goest to check out a cool new polls site she's heard about
    self.browser.get('http://localhost:8000')

    # It is obviously all about polls:
    self.assertIn('Poll', self.browser.title)

    # She clicks on the link to the first Poll, which is titled
    # "How awesome is TDD?"
    self.fail('finish this test')

    # She is taken to a poll 'results' page, which says
    # "no-one has voted on this poll yet"

    # She also sees a form, which offers her several choices.
    # There are three options with radio buttons

    # She decided to select "very awesome", which is answer #1

    # Elspeth clicks 'submit'

    # The page refreshes, and she sees that her choice
    # has updated the results.  They now say
    # "1 vote" and "100 %: very awesome".

    # Elspeth decides to try to vote again 

    # The site is not very clever (yet) so it lets her

    # She votes for another choice, and the percentages go 50%-50%

    # She votes again, and they go 66% - 33%

    # Satisfied, she goes back to sleep

[...]

----

Finish up by moving 'functional_tests.py' into the 'mysite' folder



Part 3 - Unit tests, a Django app, urls.py and views.py
======================================================

Create a polls app and run its unit tests
-----------------------------------------

Run the following command:

    python manage.py startapp polls

Your directory tree will now look like this:

    mysite
    |-- functional_test.py
    |-- manage.py
    |-- mysite
    |   |-- __init__.py
    |   |-- settings.py
    |   |-- urls.py
    |   `-- wsgi.py
    `-- polls
        |-- __init__.py
        |-- models.py
        |-- tests.py
        `-- views.py
        

Now we deliberately break the unit test at 'polls/tests.py'

[source,python]
----
from django.test import TestCase

class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)
----

To run it: `python manage.py test`


Expected Failure 1:

    settings.DATABASES is improperly configured.


NOTE: Ask me about: The difference between unit tests and functional tests

Fix in 'mysite/settings.py'
    
[source,python]
----
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', 
        'NAME': '',                      # Or path to database file if using sqlite3.
----

....
$ python manage.py test
$ python manage.py test polls
....

Expected Failure:

    ImproperlyConfigured: App with label polls could not be found

NOTE: Ask me about: re-usable apps?


[source,python]
----
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'polls',
)
----

Expected failure:

    AssertionError: 2 != 3


Django url mapping in urls.py
-----------------------------

Now change 'polls/tests.py', throwing away almost all the old stuff

[source,python]
----
from django.core.urlresolvers import resolve
from django.test import TestCase
from polls.views import home_page

class HomePageTest(TestCase):

    def test_root_url_resolves_to_home_page_view(self):
        found = resolve('/')
        self.assertEqual(found.func, home_page)
----


Expected failure:

    ImportError: cannot import name home_page



In 'polls/views.py':

[source,python]
----
# Create your views here.
home_page = None
----

NOTE: ask me about: that being totally ridiculous!

Expected failure:

    Resolver404: {'path': '', 'tried': []}


In 'mysite/urls.py' 

[source,python]
----
from django.conf.urls import patterns, include, url

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    url(r'^$', 'polls.views.home_page', name='home'),
    # url(r'^polls/', include('polls.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # url(r'^admin/', include(admin.site.urls)),
)
----

Expected failure:

    ViewDoesNotExist: Could not import polls.views.home_page. View is not callable.

NOTE: ask me about: dot-notation vs importing views.


So, in 'polls/views.py'

[source,python]
----
# Create your views here.

def home_page():
    pass
----

Test should pass!


A minimal view to return static HTML in views.py
------------------------------------------------


We extend the unit tests in 'polls/tests.py', to say we want our view
to return some static HTML...


[source,python]
----
from django.core.urlresolvers import resolve
from django.test import TestCase
from django.http import HttpRequest
from polls.views import home_page

class HomePageTest(TestCase):

    def test_root_url_resolves_to_home_page_view(self):
        found = resolve('/')
        self.assertEqual(found.func, home_page)


    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        self.assertTrue(response.content.startswith('<html>'))
        self.assertIn('<title>Poll ALL The Things</title>', response.content)
        self.assertTrue(response.content.endswith('</html>'))
----

Don't forget to import `HttpRequest`

Expected failure:

    TypeError: home_page() takes no arguments (1 given)


* Minimal code change:

[source,python]
----
def home_page(request):
    pass
----

* Tests:

....
    self.assertTrue(response.content.startswith('<html>'))
AttributeError: 'NoneType' object has no attribute 'content'
....

* Code

[source,python]
----
from django.http import HttpResponse

def home_page(request):
    return HttpResponse()
----

* Tests again:

....
    self.assertTrue(response.content.startswith('<html>'))
AssertionError: False is not true
....

* Code again:

[source,python]
----
def home_page(request):
    return HttpResponse('<html>')
----

* Tests:

....
AssertionError: '<title>Poll ALL The Things</title>' not found in '<html>'
....

* Code:


[source,python]
----
def home_page(request):
    return HttpResponse('<html><title>Poll ALL The Things</title>')
----

* Tests -- almost there?

....
    self.assertTrue(response.content.endswith('</html>'))
AssertionError: False is not true
....

* Come on, one last effort:


[source,python]
----
def home_page(request):
    return HttpResponse('<html><title>Poll ALL The Things</title></html>')
----


* Surely?

....
$ python manage.py test polls
Creating test database for alias 'default'...
..
----------------------------------------------------------------------
Ran 2 tests in 0.001s

OK
....

Now we re-run our functional test, and we expect them to get past the 
`assertIn` and stop on the `self.fail`


Part 4 - Switching to templates
===============================

We extend the FT a little:

[source,python]
----
    def test_voting_on_a_poll(self):
        # Elspeth goes to check out a cool new polls site he's heard about
        self.browser.get('http://localhost:8000')

        # It is obviously all about polls:
        self.assertIn('Poll', self.browser.title)
        heading = self.browser.find_element_by_tag_name('h1')
        self.assertEquals(heading.text, 'Current polls')

        # He clicks on the link to the first Poll, which is titled
        # "How awesome is TDD?"
        self.browser.find_element_by_link_text('How awesome is TDD?').click()

        # He is taken to a poll 'results' page, which says
        # "no-one has voted on this poll yet"
        self.fail('finish this test')
----

Expected failure is:

    NoSuchElementException: Message: u'Unable to locate element: {"method":"tag name","selector":"h1"}' ; Stacktrace: [...]


NOTE: Ask me about: `find_element_by_tag_name` vs `find_elements_by_tag_name`

Refactoring
-----------

NOTE: Ask me about: ``Don't test constants''

We start with passing tests:

----
python manage.py test polls
[...]
OK
----

----
mkdir polls/templates
----

Then open a file at 'polls/templates/home.html', to which we'll transfer our
HTML:

[source,html]
----
<html>
    <title>Poll ALL The Things</title>
</html>
----

Now change 'polls/views.py':


[source,python]
----
from django.shortcuts import render

def home_page(request):
    return render(request, 'home.html')
----

Oops, an unexpected failure:

----
    self.assertTrue(response.content.endswith('</html>'))
AssertionError: False is not true
----

Add a `print` statement to test to debug:

[source,python]
----
    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        self.assertTrue(response.content.startswith('<html>'))
        self.assertIn('<title>Poll ALL The Things</title>', response.content)
        print repr(response.content)
        self.assertTrue(response.content.endswith('</html>'))
----

And fix, in your own way.


Now we change the test:


[source,python]
----
from django.template.loader import render_to_string
[...]

    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        expected_html = render_to_string('home.html')
        self.assertEqual(response.content, expected_html)
----


NOTE: Ask me about the Django Test Client
NOTE: Ask me what Kent Beck said -- "do I really expect you to always code like
    this?"


Adding the h1 to our home page:
-------------------------------

[source,html]
----
<html>
    <head>
        <title>Poll ALL The Things</title>
    </head>
    <body>
        <h1>Current polls</h1>
    </body>
</html>
----

Expected failure: 

    NoSuchElementException: Message: u'Unable to locate element: {"method":"link text","selector":"How awesome is TDD?"}' ; Stacktrace: [...]


**Hopefully we'll have a break at this point!**


Part 5 - The Django admin site
===============================

Ask me about: testing 3rd party components

    def test_can_create_a_new_poll_via_admin_site(self):
        # Mo the administrator goes to the admin page
        self.browser.get('http://localhost:8000/admin/')

        # He sees the familiar 'Django administration' heading
        body = self.browser.find_element_by_tag_name('body')
        self.assertIn('Django administration', body.text)
        self.fail('Finish this test')


Ask me about -- DONTifying tests

Expected failure:

    AssertionError: 'Django administration' not found in u"Page not found (404)\nRequest Method: GET\nRequest URL: http://localhost:8000/admin/\nUsing the URLconf defined in mysite.urls, Django tried these URL patterns, in this order:\n^$ [name='home']\nThe current URL, admin/, didn't match any of these.\nYou're seeing this error because you have DEBUG = True in your Django settings file. Change that to False, and Django will display a standard 404 page."



(later) Ask me about: the Page pattern


