Part 1 - Getting Django set up using a Selenium Functional Test
===============================================================

Open a new file called 'functional_tests.py'

[source,python]
----
from selenium import webdriver

browser = webdriver.Firefox()
browser.get('http://localhost:8000')

assert 'Django' in browser.title
print 'OK!'
----

Expected failure:  `AssertionError`

In a separate console window:

----
django-admin.py startproject mysite
----

Should give you a folder structure like this:

----
mysite
|-- manage.py
`-- mysite
    |-- __init__.py
    |-- settings.py
    |-- urls.py
    `-- wsgi.py
----

If it doesn't, you're probably on the wrong version of Django. You'll probably
have to switch to someone else's PC.


----
cd mysite
python manage.py runserver
----

Expected pass: test prints 'OK!'

NOTE: Ask me about: what is the point of TDD? How did I get into it?
NOTE: If it doesn't work, check the port -- is `runserver` using port 8000, or is 
it on a different one? 8001?

Advanced task:
~~~~~~~~~~~~~~

Can you make the dev server run on a different port?  And adjust the FT
accordingly?  What about running just at 'http://localhost/', with no `:`?


Part 2 - `unittest` and looking for our site's home page
========================================================

We update 'functional_tests.py' to use the `unittest' module.

[source,python]
----

import unittest
from selenium import webdriver

class PollsFunctionalTest(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.browser.implicitly_wait(3)

    def tearDown(self):
        self.browser.quit()

    def test_voting_on_a_poll(self):
        # Elspeth goes to check out a cool new polls site she's heard about
        self.browser.get('http://localhost:8000')

        # It is obviously all about polls:
        self.assertIn('Poll, self.browser.title)

        self.fail('finish this test')

if __name__ == '__main__':
    unittest.main()
----

NOTE: Ask me about: why is unittest helpful?  What is assertIn?
NOTE: Ask me about: setUp, tearDown
NOTE: __name__ == '__main__' 
NOTE: self.browser.implicitly_wait()

Expected failure:  

    AssertionError: 'Polls' not found in u'Welcome to Django'


NB - if you get a message saying ``Problem loading page'' or 
``Unable to connect'', could it be because the dev server isn't running?
Use `python manage.py runserver` to start it up again...



Finish writing the FT as comments:

[source,python]
----
def test_voting_on_a_poll(self):
    # Elspeth goest to check out a cool new polls site she's heard about
    self.browser.get('http://localhost:8000')

    # It is obviously all about polls:
    self.assertIn('Poll', self.browser.title)

    # She clicks on the link to the first Poll, which is titled
    # "How awesome is TDD?"
    self.fail('finish this test')

    # She is taken to a poll 'results' page, which says
    # "no-one has voted on this poll yet"

    # She also sees a form, which offers her several choices.
    # There are three options with radio buttons

    # She decided to select "very awesome", which is answer #1

    # Elspeth clicks 'submit'

    # The page refreshes, and she sees that her choice
    # has updated the results.  They now say
    # "1 vote" and "100 %: very awesome".

    # Elspeth decides to try to vote again 

    # The site is not very clever (yet) so it lets her

    # She votes for another choice, and the percentages go 50%-50%

    # She votes again, and they go 66% - 33%

    # Satisfied, she goes back to sleep

[...]

----

Finish up by moving 'functional_tests.py' into the 'mysite' folder

Advanced task:
~~~~~~~~~~~~~~

Look up some of the other assertion methods in unittest.  Do they all make
sense?  What might you use 'assertItemsEqual' for?


Part 3 - Unit tests, a Django app, urls.py and views.py
======================================================

Create a polls app and run its unit tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Run the following command:

    python manage.py startapp polls

Your directory tree will now look like this:

    mysite
    |-- functional_test.py
    |-- manage.py
    |-- mysite
    |   |-- __init__.py
    |   |-- settings.py
    |   |-- urls.py
    |   `-- wsgi.py
    `-- polls
        |-- __init__.py
        |-- models.py
        |-- tests.py
        `-- views.py
        

Now we deliberately break the unit test at 'polls/tests.py'

[source,python]
----
from django.test import TestCase

class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)
----

To run it: `python manage.py test`


Expected Failure 1:

    settings.DATABASES is improperly configured.


NOTE: Ask me about: The difference between unit tests and functional tests

Fix in 'mysite/settings.py'
    
[source,python]
----
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', 
        'NAME': '',               # Or path to database file if using sqlite3.
----

....
$ python manage.py test
$ python manage.py test polls
....

Expected Failure:

    ImproperlyConfigured: App with label polls could not be found

NOTE: Ask me about: re-usable apps?


[source,python]
----
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'polls',
)
----

Expected failure:

    AssertionError: 2 != 3


Django url mapping in urls.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now change 'polls/tests.py', throwing away almost all the old stuff

[source,python]
----
from django.core.urlresolvers import resolve
from django.test import TestCase
from polls.views import home_page

class HomePageTest(TestCase):

    def test_root_url_resolves_to_home_page_view(self):
        found = resolve('/')
        self.assertEqual(found.func, home_page)
----


Expected failure:

    ImportError: cannot import name home_page



In 'polls/views.py':

[source,python]
----
# Create your views here.
home_page = None
----

NOTE: ask me about: that being totally ridiculous!

Expected failure:

    Resolver404: {'path': '', 'tried': []}


In 'mysite/urls.py' 

[source,python]
----
from django.conf.urls import patterns, include, url

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    url(r'^$', 'polls.views.home_page', name='home'),
    # url(r'^polls/', include('polls.foo.urls')),

    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # url(r'^admin/', include(admin.site.urls)),
)
----

Expected failure:

    ViewDoesNotExist: Could not import polls.views.home_page. View is not callable.

NOTE: ask me about: dot-notation vs importing views.


So, in 'polls/views.py'

[source,python]
----
# Create your views here.

def home_page():
    pass
----

Test should pass!

Advanced task:
~~~~~~~~~~~~~~

Would a lambda function work? Are there any other Python objects you could use
that would still get the tests to pass?


A minimal view to return static HTML in views.py
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We extend the unit tests in 'polls/tests.py', to say we want our view
to return some static HTML...


[source,python]
----
from django.core.urlresolvers import resolve
from django.test import TestCase
from django.http import HttpRequest
from polls.views import home_page

class HomePageTest(TestCase):

    def test_root_url_resolves_to_home_page_view(self):
        found = resolve('/')
        self.assertEqual(found.func, home_page)


    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        self.assertTrue(response.content.startswith('<html>'))
        self.assertIn('<title>Poll ALL The Things</title>', response.content)
        self.assertTrue(response.content.endswith('</html>'))
----

Don't forget to import `HttpRequest`

Expected failure:

    TypeError: home_page() takes no arguments (1 given)


* Minimal code change:

[source,python]
----
def home_page(request):
    pass
----

* Tests:

....
    self.assertTrue(response.content.startswith('<html>'))
AttributeError: 'NoneType' object has no attribute 'content'
....

* Code

[source,python]
----
from django.http import HttpResponse

def home_page(request):
    return HttpResponse()
----

* Tests again:

....
    self.assertTrue(response.content.startswith('<html>'))
AssertionError: False is not true
....

* Code again:

[source,python]
----
def home_page(request):
    return HttpResponse('<html>')
----

* Tests:

....
AssertionError: '<title>Poll ALL The Things</title>' not found in '<html>'
....

* Code:


[source,python]
----
def home_page(request):
    return HttpResponse('<html><title>Poll ALL The Things</title>')
----

* Tests -- almost there?

....
    self.assertTrue(response.content.endswith('</html>'))
AssertionError: False is not true
....

* Come on, one last effort:


[source,python]
----
def home_page(request):
    return HttpResponse('<html><title>Poll ALL The Things</title></html>')
----


* Surely?

....
$ python manage.py test polls
Creating test database for alias 'default'...
..
----------------------------------------------------------------------
Ran 2 tests in 0.001s

OK
....

Now we re-run our functional test, and we expect them to get past the 
`assertIn` and stop on the `self.fail`


Part 4 - Switching to templates
===============================

We extend the FT a little:

[source,python]
----
    def test_voting_on_a_poll(self):
        # Elspeth goes to check out a cool new polls site he's heard about
        self.browser.get('http://localhost:8000')

        # It is obviously all about polls:
        self.assertIn('Poll', self.browser.title)
        heading = self.browser.find_element_by_tag_name('h1')
        self.assertEquals(heading.text, 'Current polls')

        # He clicks on the link to the first Poll, which is titled
        # "How awesome is TDD?"
        self.browser.find_element_by_link_text('How awesome is TDD?').click()

        # He is taken to a poll 'results' page, which says
        # "no-one has voted on this poll yet"
        self.fail('finish this test')
----

Expected failure is:

    NoSuchElementException: Message: u'Unable to locate element: {"method":"tag
    name","selector":"h1"}' ; Stacktrace: [...]


NOTE: Ask me about: `find_element_by_tag_name` vs `find_elements_by_tag_name`



Refactoring
~~~~~~~~~~~

NOTE: Ask me about: ``Don't test constants''

We start with passing tests:

----
python manage.py test polls
[...]
OK
----

----
mkdir polls/templates
----

Then open a file at 'polls/templates/home.html', to which we'll transfer our
HTML:

[source,html]
----
<html>
    <title>Poll ALL The Things</title>
</html>
----

Now change 'polls/views.py':


[source,python]
----
from django.shortcuts import render

def home_page(request):
    return render(request, 'home.html')
----

Oops, an unexpected failure:

----
    self.assertTrue(response.content.endswith('</html>'))
AssertionError: False is not true
----

Add a `print` statement to test to debug:

[source,python]
----
    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        self.assertTrue(response.content.startswith('<html>'))
        self.assertIn('<title>Poll ALL The Things</title>', response.content)
        print repr(response.content)
        self.assertTrue(response.content.endswith('</html>'))
----

And fix, in your own way.


Now we change the test:


[source,python]
----
from django.template.loader import render_to_string
[...]

    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        expected_html = render_to_string('home.html')
        self.assertEqual(response.content, expected_html)
----


NOTE: Ask me about the Django Test Client
NOTE: Ask me what Kent Beck said -- "do I really expect you to always code like
    this?"


Adding the h1 to our home page:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[source,html]
----
<html>
    <head>
        <title>Poll ALL The Things</title>
    </head>
    <body>
        <h1>Current polls</h1>
    </body>
</html>
----

Expected failure: 

    NoSuchElementException: Message: u'Unable to locate element:
    {"method":"link text","selector":"How awesome is TDD?"}' ; Stacktrace:
    [...]

**Hopefully we'll have a break at this point!**


Part 5 - The Django admin site
===============================

Add a new test method to 'functional_tests.py':

    def test_can_create_a_new_poll_via_admin_site(self):
        # Mo the administrator goes to the admin page
        self.browser.get('http://localhost:8000/admin/')

        # He sees the familiar 'Django administration' heading
        body = self.browser.find_element_by_tag_name('body')
        self.assertIn('Django administration', body.text)
        self.fail('Finish this test')


NOTE: Ask me about -- DONTifying tests

Expected failure:

    AssertionError: 'Django administration' not found in u"Page not found
    (404)\nRequest Method: GET\nRequest URL:
    http://localhost:8000/admin/\nUsing the URLconf defined in mysite.urls,
    Django tried these URL patterns, in this order:\n^$ [name='home']\nThe
    current URL, admin/, didn't match any of these.\nYou're seeing this error
    because you have DEBUG = True in your Django settings file. Change that to
    False, and Django will display a standard 404 page."


Switch on the admin involves uncommenting 3 lines in 2 files:

'mysite/settings.py':

[source,python]
----
INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Uncomment the next line to enable the admin:
    'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
    'polls',
)
----

'mysite/urls.py':

[source,python]
----
# Uncomment the next two lines to enable the admin:
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
    # Examples:
    url(r'^$', 'polls.views.home_page', name='home'),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),
)
----

Expected failure (at the top of a long traceback):

    AssertionError: 'Django administration' not found in u'ImproperlyConfigured
    at /admin/\nsettings.DATABASES is improperly configured. Please supply the
    NAME value.\nRequest Method: GET\ [...]


Add a database name in 'settings.py':

[source,python]
----
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', 
        'NAME': 'db.sqlite', # Or path to database file if using sqlite3.
----

Expected failure (at the top of a long traceback):

    AssertionError: 'Django administration' not found in u"DatabaseError at
    /admin/\nno such table: django_site\nRequest Method:

Run syncdb

----
python manage.py syncdb
----

Remember the username and password you use -- I'm using 'admin' and 'adm1n'

Should now get to:

    AssertionError: Finish this test

[source,python]
----

    def test_can_create_a_new_poll_via_admin_site(self):
        # Mo the administrator goes to the admin page
        self.browser.get('http://localhost:8000/admin/')

        # He sees the familiar 'Django administration' heading
        body = self.browser.find_element_by_tag_name('body')
        self.assertIn('Django administration', body.text)

        # He types in his username and passwords and hits return
        username_field = self.browser.find_element_by_name('username')
        username_field.send_keys('admin')

        password_field = self.browser.find_element_by_name('password')
        password_field.send_keys('adm1n')
        password_field.send_keys(Keys.RETURN)

        # His username and password are accepted, and he is taken to
        # the Site Administration page
        body = self.browser.find_element_by_tag_name('body')
        self.assertIn('Site administration', body.text)

        self.fail('Use the admin site to create a poll')

----

Expected failure:

    AssertionError: Use the admin site to create a poll


Part 6: A model for Polls
=========================

Extend the FT:

        [...]
        # His username and password are accepted, and he is taken to
        # the Site Administration page
        body = self.browser.find_element_by_tag_name('body')
        self.assertIn('Site administration', body.text)

        # He sees a section named "Polls" with a model called "Polls" in it
        polls_links = self.browser.find_elements_by_link_text('Polls')
        self.assertEquals(len(polls_links), 2)
        self.fail('Use the admin site to create a poll')

Expected failure:

----
    self.assertEquals(len(polls_links), 2)
AssertionError: 0 != 2
----

Unit test for our Poll model:

[source,python]
----
from django.core.urlresolvers import resolve
from django.http import HttpRequest
from django.test import TestCase
from django.utils import timezone
from polls.models import Poll
from polls.views import home_page

class PollModelTest(TestCase):

    def test_creating_a_new_poll_and_saving_it_to_the_database(self):
        # start by creating a new Poll object with its "question" set
        poll = Poll()
        poll.question = "What's up?"
        poll.pub_date = timezone.now()

        # check we can save it to the database
        poll.save()

        # now check we can find it in the database again
        all_polls_in_database = Poll.objects.all()
        self.assertEquals(len(all_polls_in_database), 1)
        only_poll_in_database = all_polls_in_database[0]
        self.assertEquals(only_poll_in_database, poll)

        # and check that it's saved its two attributes: question and pub_date
        self.assertEquals(only_poll_in_database.question, "What's up?")
        self.assertEquals(only_poll_in_database.pub_date, poll.pub_date)


class HomePageTest(TestCase):

    def test_root_url_resolves_to_home_page_view(self):
        [...]
----

Don't miss the 2 extra imports (I did!)

* Expected failure:

    ImportError: cannot import name Poll

* Now edit 'polls/models.py':

[source,python]
----
from django.db import models

Poll = None
----

* Expected failure:

----
TypeError: 'NoneType' object is not callable
    ImportError: cannot import name Poll
----

* 'models.py':

[source,python]
----
from django.db import models

class Poll(object):
    pass
----

* failure:

    AttributeError: 'Poll' object has no attribute 'save'

* inherit:

[source,python]
----
class Poll(models.Model):
    pass
----

* failure - note it's quite late!

    AttributeError: 'Poll' object has no attribute 'question'

* add question attribute

[source,python]
----
class Poll(models.Model):
    question = models.CharField(max_length=200)
----

* new failure:

    AttributeError: 'Poll' object has no attribute 'pub_date'

* new field - deliberately wrong:


[source,python]
----
class Poll(models.Model):
    question = models.CharField(max_length=200)
    pub_date = models.CharField(max_length=200)
----

* sure enough, tests help us:

    AssertionError: u'2013-03-03 12:40:29.241235+00:00' !=
    datetime.datetime(2013, 3, 3, 12, 40, 29, 241235, tzinfo=<UTC>)

* fix

[source,python]
----
    pub_date = models.DateTimeField()
----

* and it should now work!

....
$ python manage.py test polls
Creating test database for alias 'default'...
...
----------------------------------------------------------------------
Ran 3 tests in 0.008s

OK
....


Do the FTs pass?  No, still need to 'register' Polls in the admin site,
using a new file at 'polls/admin.py'

[source,python]
----
from django.contrib import admin
from polls.models import Poll

admin.site.register(Poll)
----

And now we should get our self.fail:

    AssertionError: Use the admin site to create a poll


Advanced task:
~~~~~~~~~~~~~~

Give pub_date a verbose name of 'Date published'. See the
official tutorial for the implementation... but can you find a way to unit test
it?  Hint: the model `._meta` attribute might work... Is there another way?


Part 7 (optional): Adding related Choice model & switching to LiveServerTestCase
================================================================================

Start by extending the FT to actually create a new poll via the admin site:

[source,python]
----
    # He clicks the 'Add poll' link
    new_poll_link = self.browser.find_element_by_link_text('Add poll')
    new_poll_link.click()

    # He types in an interesting question for the Poll
    question_field = self.browser.find_element_by_name('question')
    question_field.send_keys("How awesome is Test-Driven Development?")

    # He sets the date and time of publication - it'll be a new year's
    # poll!
    date_field = self.browser.find_element_by_name('pub_date_0')
    date_field.send_keys('01/01/12')
    time_field = self.browser.find_element_by_name('pub_date_1')
    time_field.send_keys('00:00')

    # Mo clicks the save button
    save_button = self.browser.find_element_by_css_selector("input[value='Save']")
    save_button.click()

    # He is returned to the "Polls" listing, where he can see his
    # new poll, listed as a clickable link
    new_poll_links = self.browser.find_elements_by_link_text(
            "How awesome is Test-Driven Development?"
    )
    self.assertEquals(len(new_poll_links), 1)
----

First expected fail - 

    self.assertEquals(len(new_poll_links), 1)
AssertionError: 0 != 1

Fix by changing the string representation of a poll:

in 'polls/tests.py', add to `PollModelTest`:


[source,python]
----
    def test_string_representation(self):
        poll = Poll()
        poll.question = "Why?"
        self.assertEqual(unicode(poll), "Why?")
----

Expected fail:

    AssertionError: u'Poll object' != 'Why?'

'models.py':




Part 8 - Listing polls on the home page template
================================================


NOTE: (later) Ask me about: the Page pattern

